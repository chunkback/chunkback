> âš ï¸ **AI-GENERATED DOCUMENTATION**
>
> This page is automatically generated from AI with human review and light editing
> Be weary of possible logical errors, feel free to make PRs to it.

# Contributing to Chunkback

Thank you for your interest in contributing to Chunkback! This document provides guidelines and instructions for contributing to the project.

## Table of Contents

- [Prerequisites](#prerequisites)
- [Getting Started](#getting-started)
- [Development Workflow](#development-workflow)
- [Adding New CBPL Commands](#adding-new-cbpl-commands)
- [Running Tests](#running-tests)
- [Code Style](#code-style)
- [Submitting Changes](#submitting-changes)

## Prerequisites

Before you begin, ensure you have the following installed:

- **Node.js** (v22 or higher) - [Download](https://nodejs.org/)
- **pnpm** (v10 or higher) - Install with `npm install -g pnpm`
- **Git** - [Download](https://git-scm.com/)
- **A code editor**

## Getting Started

1. **Fork the repository** on GitHub
2. **Clone your fork** locally:
   ```bash
   git clone https://github.com/YOUR_USERNAME/chunkback-monorepo.git
   cd chunkback-monorepo/apps/api
   ```
3. **Install dependencies**:
   ```bash
   pnpm install
   ```
4. **Build the project**:
   ```bash
   pnpm build
   ```
5. **Run tests** to ensure everything works:
   ```bash
   pnpm test:all
   ```

## Development Workflow

### Project Structure

```
apps/api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ parser/           # CBPL lexer and parser
â”‚   â”‚   â”œâ”€â”€ lexer/        # Tokenization
â”‚   â”‚   â”œâ”€â”€ cbpl-parser/  # AST generation
â”‚   â”‚   â”œâ”€â”€ definitions/  # Generated types (DO NOT EDIT)
â”‚   â”‚   â””â”€â”€ types/        # Command type definitions
â”‚   â”œâ”€â”€ streaming/        # Response streaming logic
â”‚   â””â”€â”€ server/           # Express server and routes
â”œâ”€â”€ e2e/                  # End-to-end tests
â”œâ”€â”€ scripts/              # Code generation scripts
â”œâ”€â”€ cbpl.definitions.json # CBPL language definition (source of truth)
â””â”€â”€ CBPL.md              # Auto-generated documentation
```

### Key Commands

```bash
# Development
pnpm dev                  # Start dev server with hot reload
pnpm build               # Build TypeScript to dist/
pnpm start               # Run built server

# Testing
pnpm test:unit           # Run unit tests
pnpm test:e2e            # Run end-to-end tests
pnpm test:all            # Run all tests

# Code Quality
pnpm lint                # Run oxlint
pnpm format              # Format with prettier
pnpm typecheck           # Type check with tsc

# Code Generation
pnpm codegen             # Generate types and docs from cbpl.definitions.json
```

## Adding New CBPL Commands

CBPL uses a **single source of truth** for definiting commands. All command definitions live in `cbpl.definitions.json`, and the types that you can use in the codebase are autogenerated from it via `pnpm codegen`.

### Step 1: Edit `cbpl.definitions.json`

Add your new command to the `commands` object:

```json
{
  "version": "1.0.0",
  "commands": {
    "NEWCOMMAND": {
      "name": "NEWCOMMAND",
      "description": "Does something awesome",
      "parameters": [
        {
          "name": "paramName",
          "type": "string",
          "description": "Description of parameter"
        }
      ],
      "examples": ["NEWCOMMAND \"example value\""]
    }
  }
}
```

**Important rules:**

- Command keys must be **UPPERCASE** (e.g., `"SAY"`, `"TOOLCALL"`)
- `name` field must match the object key
- Parameter `type` must be either `"string"` or `"number"`
- For `number` types, you can add optional validation:
  ```json
  {
    "name": "size",
    "type": "number",
    "description": "Size value",
    "validation": {
      "min": 1,
      "max": 1000
    }
  }
  ```
- Must have at least one parameter and one example

### Step 2: Run Code Generation

```bash
pnpm codegen
```

This generates:

- `src/parser/definitions/cbpl.generated.ts` - TypeScript types and Zod schemas
- `CBPL.md` - Updated documentation

### Step 3: Update the Lexer

Add the new token type to `src/parser/lexer/token.types.ts`:

```typescript
export enum TokenType {
  // Add your command here
  NEWCOMMAND = 'NEWCOMMAND',
  // ... existing commands
}
```

### Step 4: Update the Parser

Add parsing logic in `src/parser/cbpl-parser/cbpl-parser.ts`:

```typescript
private parseStatement(): Command {
  switch (this.currentToken.type) {
    case TokenType.NEWCOMMAND:
      return this.parseNewCommandStatement();
    // ... existing cases
  }
}

private parseNewCommandStatement(): NewCommandCommand {
  this.expect(TokenType.NEWCOMMAND);
  const paramName = this.expect(TokenType.STRING);

  return {
    type: 'NEWCOMMAND',
    paramName: paramName.value as string,
  };
}
```

### Step 5: Update Streaming Logic

Add execution logic in `src/streaming/` to handle your new command.

### Step 6: Add Tests

1. **Unit tests** for the lexer/parser (`src/parser/lexer/lexer.test.ts`)
2. **E2E tests** for each provider (`e2e/openai/`, `e2e/anthropic/`, `e2e/gemini/`)

Example unit test:

```typescript
it('should tokenize NEWCOMMAND statement', () => {
  const tokens = tokenize('NEWCOMMAND "value"');
  expect(tokens).toHaveLength(3);
  expect(tokens[0].type).toBe(TokenType.NEWCOMMAND);
  expect(tokens[1].type).toBe(TokenType.STRING);
  expect(tokens[1].value).toBe('value');
});
```

### Step 7: Verify Everything

```bash
pnpm typecheck       # TypeScript should pass
pnpm lint            # Linting should pass
pnpm test:all        # All tests should pass
```

## Running Tests

### Unit Tests

```bash
pnpm test:unit
```

Tests the lexer, parser, and core logic in isolation.

### E2E Tests

```bash
pnpm test:e2e
```

Tests actual streaming responses from OpenAI, Anthropic, and Gemini APIs.

### Test Coverage

The test suite includes:

- **Lexer tests**: Tokenization of all CBPL commands
- **Parser tests**: AST generation
- **E2E tests**: Real API responses for each provider
- **Coverage validator**: Ensures all commands are tested

### Writing Tests

- Unit tests go in `src/**/*.test.ts`
- E2E tests go in `e2e/**/*.test.ts`
- Use the existing test cases as templates
- Follow the naming convention: `should <behavior> when <condition>`

## Code Style

Chunkback uses automated code formatting and linting:

### Pre-commit Hooks

We use **Husky** and **lint-staged** to automatically run checks before commits:

1. **Prettier** formats all code
2. **Oxlint** checks for errors
3. **TypeScript** type checks

If any check fails, the commit will be rejected. Fix the errors and try again.

### Manual Formatting

```bash
pnpm format          # Format all files with Prettier
pnpm lint            # Check for lint errors
pnpm lint --fix      # Auto-fix lint errors where possible
```

### Style Guidelines

- Use **TypeScript** for all code
- Use **functional components** and hooks (if adding React later)
- Prefer `const` over `let`
- Use **descriptive variable names** (e.g., `parsedCommand` not `pc`)
- Add **JSDoc comments** for public APIs
- Keep functions **small and focused** (single responsibility)

### File Naming

- Source files: `kebab-case.ts` (e.g., `cbpl-parser.ts`)
- Test files: `kebab-case.test.ts` (e.g., `cbpl-parser.test.ts`)
- Type files: `kebab-case.types.ts` (e.g., `command.types.ts`)

## Submitting Changes

### 1. Create a Branch

```bash
git checkout -b feature/your-feature-name
# or
git checkout -b fix/your-bug-fix
```

### 2. Make Your Changes

- Write clear, concise commit messages
- Keep commits focused (one logical change per commit)
- Follow the code style guidelines

### 3. Run All Checks

```bash
pnpm typecheck       # Must pass
pnpm lint            # Must pass
pnpm test:all        # Must pass
pnpm codegen         # If you edited cbpl.definitions.json
```

### 4. Push to Your Fork

```bash
git push origin feature/your-feature-name
```

### 5. Open a Pull Request

- Go to the original repository on GitHub
- Click "New Pull Request"
- Select your fork and branch
- Fill out the PR template with:
  - **Description** of changes
  - **Motivation** for the change
  - **Testing** performed
  - **Related issues** (if any)

### PR Checklist

Before submitting, ensure:

- [ ] All tests pass (`pnpm test:all`)
- [ ] Type checking passes (`pnpm typecheck`)
- [ ] Linting passes (`pnpm lint`)
- [ ] Code is formatted (`pnpm format`)
- [ ] If adding/changing CBPL commands, ran `pnpm codegen`
- [ ] Added tests for new functionality
- [ ] Updated documentation if needed
- [ ] Commit messages are clear and descriptive

## Questions?

- Open an issue on GitHub
- Tag maintainers in your PR if you need help
- Be patient - we're a small team!

## Code of Conduct

Be respectful, inclusive, and constructive. We're all here to build something great together.

---

Thank you for contributing to Chunkback! ðŸš€
